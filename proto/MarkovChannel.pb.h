// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MarkovChannel.proto

#ifndef PROTOBUF_MarkovChannel_2eproto__INCLUDED
#define PROTOBUF_MarkovChannel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MarkovChannel {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MarkovChannel_2eproto();
void protobuf_AssignDesc_MarkovChannel_2eproto();
void protobuf_ShutdownFile_MarkovChannel_2eproto();

class ProtocolParameter;
class ProtocolStep;
class SolverParameter;
class ModelParameter;
class MutationParameter;
class GAParameter;
class SAParameter;
class TransitionParameter;

enum ProtocolStep_StepType {
  ProtocolStep_StepType_NONE = 0,
  ProtocolStep_StepType_PEAK = 1,
  ProtocolStep_StepType_TAU = 2,
  ProtocolStep_StepType_TRACE = 3
};
bool ProtocolStep_StepType_IsValid(int value);
const ProtocolStep_StepType ProtocolStep_StepType_StepType_MIN = ProtocolStep_StepType_NONE;
const ProtocolStep_StepType ProtocolStep_StepType_StepType_MAX = ProtocolStep_StepType_TRACE;
const int ProtocolStep_StepType_StepType_ARRAYSIZE = ProtocolStep_StepType_StepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocolStep_StepType_descriptor();
inline const ::std::string& ProtocolStep_StepType_Name(ProtocolStep_StepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocolStep_StepType_descriptor(), value);
}
inline bool ProtocolStep_StepType_Parse(
    const ::std::string& name, ProtocolStep_StepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolStep_StepType>(
    ProtocolStep_StepType_descriptor(), name, value);
}
enum SolverParameter_SolverMode {
  SolverParameter_SolverMode_GENETIC_ALGORITHM = 0,
  SolverParameter_SolverMode_SIMULATED_ANNEALING = 1
};
bool SolverParameter_SolverMode_IsValid(int value);
const SolverParameter_SolverMode SolverParameter_SolverMode_SolverMode_MIN = SolverParameter_SolverMode_GENETIC_ALGORITHM;
const SolverParameter_SolverMode SolverParameter_SolverMode_SolverMode_MAX = SolverParameter_SolverMode_SIMULATED_ANNEALING;
const int SolverParameter_SolverMode_SolverMode_ARRAYSIZE = SolverParameter_SolverMode_SolverMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_SolverMode_descriptor();
inline const ::std::string& SolverParameter_SolverMode_Name(SolverParameter_SolverMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_SolverMode_descriptor(), value);
}
inline bool SolverParameter_SolverMode_Parse(
    const ::std::string& name, SolverParameter_SolverMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_SolverMode>(
    SolverParameter_SolverMode_descriptor(), name, value);
}
enum SolverParameter_SimulationMode {
  SolverParameter_SimulationMode_ODE = 0,
  SolverParameter_SimulationMode_EXPM = 1
};
bool SolverParameter_SimulationMode_IsValid(int value);
const SolverParameter_SimulationMode SolverParameter_SimulationMode_SimulationMode_MIN = SolverParameter_SimulationMode_ODE;
const SolverParameter_SimulationMode SolverParameter_SimulationMode_SimulationMode_MAX = SolverParameter_SimulationMode_EXPM;
const int SolverParameter_SimulationMode_SimulationMode_ARRAYSIZE = SolverParameter_SimulationMode_SimulationMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_SimulationMode_descriptor();
inline const ::std::string& SolverParameter_SimulationMode_Name(SolverParameter_SimulationMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_SimulationMode_descriptor(), value);
}
inline bool SolverParameter_SimulationMode_Parse(
    const ::std::string& name, SolverParameter_SimulationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_SimulationMode>(
    SolverParameter_SimulationMode_descriptor(), name, value);
}
enum GAParameter_SelectionMode {
  GAParameter_SelectionMode_TOURNAMENT = 0,
  GAParameter_SelectionMode_PROPORTIONATE = 1,
  GAParameter_SelectionMode_STOCHASTIC = 2,
  GAParameter_SelectionMode_UNIFORM = 3,
  GAParameter_SelectionMode_ROULETTE = 4,
  GAParameter_SelectionMode_RANK = 5
};
bool GAParameter_SelectionMode_IsValid(int value);
const GAParameter_SelectionMode GAParameter_SelectionMode_SelectionMode_MIN = GAParameter_SelectionMode_TOURNAMENT;
const GAParameter_SelectionMode GAParameter_SelectionMode_SelectionMode_MAX = GAParameter_SelectionMode_RANK;
const int GAParameter_SelectionMode_SelectionMode_ARRAYSIZE = GAParameter_SelectionMode_SelectionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GAParameter_SelectionMode_descriptor();
inline const ::std::string& GAParameter_SelectionMode_Name(GAParameter_SelectionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GAParameter_SelectionMode_descriptor(), value);
}
inline bool GAParameter_SelectionMode_Parse(
    const ::std::string& name, GAParameter_SelectionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GAParameter_SelectionMode>(
    GAParameter_SelectionMode_descriptor(), name, value);
}
// ===================================================================

class ProtocolParameter : public ::google::protobuf::Message {
 public:
  ProtocolParameter();
  virtual ~ProtocolParameter();

  ProtocolParameter(const ProtocolParameter& from);

  inline ProtocolParameter& operator=(const ProtocolParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolParameter& default_instance();

  void Swap(ProtocolParameter* other);

  // implements Message ----------------------------------------------

  ProtocolParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolParameter& from);
  void MergeFrom(const ProtocolParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional double v0 = 3 [default = -120];
  inline bool has_v0() const;
  inline void clear_v0();
  static const int kV0FieldNumber = 3;
  inline double v0() const;
  inline void set_v0(double value);

  // optional double temperature = 4 [default = 293];
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 4;
  inline double temperature() const;
  inline void set_temperature(double value);

  // repeated .MarkovChannel.ProtocolStep step = 5;
  inline int step_size() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline const ::MarkovChannel::ProtocolStep& step(int index) const;
  inline ::MarkovChannel::ProtocolStep* mutable_step(int index);
  inline ::MarkovChannel::ProtocolStep* add_step();
  inline const ::google::protobuf::RepeatedPtrField< ::MarkovChannel::ProtocolStep >&
      step() const;
  inline ::google::protobuf::RepeatedPtrField< ::MarkovChannel::ProtocolStep >*
      mutable_step();

  // @@protoc_insertion_point(class_scope:MarkovChannel.ProtocolParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_v0();
  inline void clear_has_v0();
  inline void set_has_temperature();
  inline void clear_has_temperature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* source_;
  double v0_;
  double temperature_;
  ::google::protobuf::RepeatedPtrField< ::MarkovChannel::ProtocolStep > step_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static ProtocolParameter* default_instance_;
};
// -------------------------------------------------------------------

class ProtocolStep : public ::google::protobuf::Message {
 public:
  ProtocolStep();
  virtual ~ProtocolStep();

  ProtocolStep(const ProtocolStep& from);

  inline ProtocolStep& operator=(const ProtocolStep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolStep& default_instance();

  void Swap(ProtocolStep* other);

  // implements Message ----------------------------------------------

  ProtocolStep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolStep& from);
  void MergeFrom(const ProtocolStep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProtocolStep_StepType StepType;
  static const StepType NONE = ProtocolStep_StepType_NONE;
  static const StepType PEAK = ProtocolStep_StepType_PEAK;
  static const StepType TAU = ProtocolStep_StepType_TAU;
  static const StepType TRACE = ProtocolStep_StepType_TRACE;
  static inline bool StepType_IsValid(int value) {
    return ProtocolStep_StepType_IsValid(value);
  }
  static const StepType StepType_MIN =
    ProtocolStep_StepType_StepType_MIN;
  static const StepType StepType_MAX =
    ProtocolStep_StepType_StepType_MAX;
  static const int StepType_ARRAYSIZE =
    ProtocolStep_StepType_StepType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StepType_descriptor() {
    return ProtocolStep_StepType_descriptor();
  }
  static inline const ::std::string& StepType_Name(StepType value) {
    return ProtocolStep_StepType_Name(value);
  }
  static inline bool StepType_Parse(const ::std::string& name,
      StepType* value) {
    return ProtocolStep_StepType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double dt = 1;
  inline bool has_dt() const;
  inline void clear_dt();
  static const int kDtFieldNumber = 1;
  inline double dt() const;
  inline void set_dt(double value);

  // optional double vm = 2;
  inline bool has_vm() const;
  inline void clear_vm();
  static const int kVmFieldNumber = 2;
  inline double vm() const;
  inline void set_vm(double value);

  // optional bool conductance = 3;
  inline bool has_conductance() const;
  inline void clear_conductance();
  static const int kConductanceFieldNumber = 3;
  inline bool conductance() const;
  inline void set_conductance(bool value);

  // optional bool fluorimetry = 4;
  inline bool has_fluorimetry() const;
  inline void clear_fluorimetry();
  static const int kFluorimetryFieldNumber = 4;
  inline bool fluorimetry() const;
  inline void set_fluorimetry(bool value);

  // optional .MarkovChannel.ProtocolStep.StepType stype = 5 [default = NONE];
  inline bool has_stype() const;
  inline void clear_stype();
  static const int kStypeFieldNumber = 5;
  inline ::MarkovChannel::ProtocolStep_StepType stype() const;
  inline void set_stype(::MarkovChannel::ProtocolStep_StepType value);

  // optional bool normalize = 6 [default = true];
  inline bool has_normalize() const;
  inline void clear_normalize();
  static const int kNormalizeFieldNumber = 6;
  inline bool normalize() const;
  inline void set_normalize(bool value);

  // optional double prm1 = 7 [default = 0.1];
  inline bool has_prm1() const;
  inline void clear_prm1();
  static const int kPrm1FieldNumber = 7;
  inline double prm1() const;
  inline void set_prm1(double value);

  // optional double prm2 = 8 [default = 0.9];
  inline bool has_prm2() const;
  inline void clear_prm2();
  static const int kPrm2FieldNumber = 8;
  inline double prm2() const;
  inline void set_prm2(double value);

  // optional double stepsize = 9 [default = 0.1];
  inline bool has_stepsize() const;
  inline void clear_stepsize();
  static const int kStepsizeFieldNumber = 9;
  inline double stepsize() const;
  inline void set_stepsize(double value);

  // @@protoc_insertion_point(class_scope:MarkovChannel.ProtocolStep)
 private:
  inline void set_has_dt();
  inline void clear_has_dt();
  inline void set_has_vm();
  inline void clear_has_vm();
  inline void set_has_conductance();
  inline void clear_has_conductance();
  inline void set_has_fluorimetry();
  inline void clear_has_fluorimetry();
  inline void set_has_stype();
  inline void clear_has_stype();
  inline void set_has_normalize();
  inline void clear_has_normalize();
  inline void set_has_prm1();
  inline void clear_has_prm1();
  inline void set_has_prm2();
  inline void clear_has_prm2();
  inline void set_has_stepsize();
  inline void clear_has_stepsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double dt_;
  double vm_;
  bool conductance_;
  bool fluorimetry_;
  bool normalize_;
  int stype_;
  double prm1_;
  double prm2_;
  double stepsize_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static ProtocolStep* default_instance_;
};
// -------------------------------------------------------------------

class SolverParameter : public ::google::protobuf::Message {
 public:
  SolverParameter();
  virtual ~SolverParameter();

  SolverParameter(const SolverParameter& from);

  inline SolverParameter& operator=(const SolverParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverParameter& default_instance();

  void Swap(SolverParameter* other);

  // implements Message ----------------------------------------------

  SolverParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverParameter& from);
  void MergeFrom(const SolverParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SolverParameter_SolverMode SolverMode;
  static const SolverMode GENETIC_ALGORITHM = SolverParameter_SolverMode_GENETIC_ALGORITHM;
  static const SolverMode SIMULATED_ANNEALING = SolverParameter_SolverMode_SIMULATED_ANNEALING;
  static inline bool SolverMode_IsValid(int value) {
    return SolverParameter_SolverMode_IsValid(value);
  }
  static const SolverMode SolverMode_MIN =
    SolverParameter_SolverMode_SolverMode_MIN;
  static const SolverMode SolverMode_MAX =
    SolverParameter_SolverMode_SolverMode_MAX;
  static const int SolverMode_ARRAYSIZE =
    SolverParameter_SolverMode_SolverMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolverMode_descriptor() {
    return SolverParameter_SolverMode_descriptor();
  }
  static inline const ::std::string& SolverMode_Name(SolverMode value) {
    return SolverParameter_SolverMode_Name(value);
  }
  static inline bool SolverMode_Parse(const ::std::string& name,
      SolverMode* value) {
    return SolverParameter_SolverMode_Parse(name, value);
  }

  typedef SolverParameter_SimulationMode SimulationMode;
  static const SimulationMode ODE = SolverParameter_SimulationMode_ODE;
  static const SimulationMode EXPM = SolverParameter_SimulationMode_EXPM;
  static inline bool SimulationMode_IsValid(int value) {
    return SolverParameter_SimulationMode_IsValid(value);
  }
  static const SimulationMode SimulationMode_MIN =
    SolverParameter_SimulationMode_SimulationMode_MIN;
  static const SimulationMode SimulationMode_MAX =
    SolverParameter_SimulationMode_SimulationMode_MAX;
  static const int SimulationMode_ARRAYSIZE =
    SolverParameter_SimulationMode_SimulationMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SimulationMode_descriptor() {
    return SolverParameter_SimulationMode_descriptor();
  }
  static inline const ::std::string& SimulationMode_Name(SimulationMode value) {
    return SolverParameter_SimulationMode_Name(value);
  }
  static inline bool SimulationMode_Parse(const ::std::string& name,
      SimulationMode* value) {
    return SolverParameter_SimulationMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .MarkovChannel.SolverParameter.SolverMode solver_mode = 1 [default = GENETIC_ALGORITHM];
  inline bool has_solver_mode() const;
  inline void clear_solver_mode();
  static const int kSolverModeFieldNumber = 1;
  inline ::MarkovChannel::SolverParameter_SolverMode solver_mode() const;
  inline void set_solver_mode(::MarkovChannel::SolverParameter_SolverMode value);

  // optional .MarkovChannel.SolverParameter.SimulationMode simulation_mode = 2 [default = ODE];
  inline bool has_simulation_mode() const;
  inline void clear_simulation_mode();
  static const int kSimulationModeFieldNumber = 2;
  inline ::MarkovChannel::SolverParameter_SimulationMode simulation_mode() const;
  inline void set_simulation_mode(::MarkovChannel::SolverParameter_SimulationMode value);

  // required .MarkovChannel.ModelParameter model_param = 3;
  inline bool has_model_param() const;
  inline void clear_model_param();
  static const int kModelParamFieldNumber = 3;
  inline const ::MarkovChannel::ModelParameter& model_param() const;
  inline ::MarkovChannel::ModelParameter* mutable_model_param();
  inline ::MarkovChannel::ModelParameter* release_model_param();
  inline void set_allocated_model_param(::MarkovChannel::ModelParameter* model_param);

  // optional int32 max_iters = 4 [default = 10000];
  inline bool has_max_iters() const;
  inline void clear_max_iters();
  static const int kMaxItersFieldNumber = 4;
  inline ::google::protobuf::int32 max_iters() const;
  inline void set_max_iters(::google::protobuf::int32 value);

  // optional .MarkovChannel.GAParameter ga_param = 5;
  inline bool has_ga_param() const;
  inline void clear_ga_param();
  static const int kGaParamFieldNumber = 5;
  inline const ::MarkovChannel::GAParameter& ga_param() const;
  inline ::MarkovChannel::GAParameter* mutable_ga_param();
  inline ::MarkovChannel::GAParameter* release_ga_param();
  inline void set_allocated_ga_param(::MarkovChannel::GAParameter* ga_param);

  // optional .MarkovChannel.SAParameter sa_param = 6;
  inline bool has_sa_param() const;
  inline void clear_sa_param();
  static const int kSaParamFieldNumber = 6;
  inline const ::MarkovChannel::SAParameter& sa_param() const;
  inline ::MarkovChannel::SAParameter* mutable_sa_param();
  inline ::MarkovChannel::SAParameter* release_sa_param();
  inline void set_allocated_sa_param(::MarkovChannel::SAParameter* sa_param);

  // @@protoc_insertion_point(class_scope:MarkovChannel.SolverParameter)
 private:
  inline void set_has_solver_mode();
  inline void clear_has_solver_mode();
  inline void set_has_simulation_mode();
  inline void clear_has_simulation_mode();
  inline void set_has_model_param();
  inline void clear_has_model_param();
  inline void set_has_max_iters();
  inline void clear_has_max_iters();
  inline void set_has_ga_param();
  inline void clear_has_ga_param();
  inline void set_has_sa_param();
  inline void clear_has_sa_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int solver_mode_;
  int simulation_mode_;
  ::MarkovChannel::ModelParameter* model_param_;
  ::MarkovChannel::GAParameter* ga_param_;
  ::MarkovChannel::SAParameter* sa_param_;
  ::google::protobuf::int32 max_iters_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static SolverParameter* default_instance_;
};
// -------------------------------------------------------------------

class ModelParameter : public ::google::protobuf::Message {
 public:
  ModelParameter();
  virtual ~ModelParameter();

  ModelParameter(const ModelParameter& from);

  inline ModelParameter& operator=(const ModelParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelParameter& default_instance();

  void Swap(ModelParameter* other);

  // implements Message ----------------------------------------------

  ModelParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelParameter& from);
  void MergeFrom(const ModelParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 min_states = 1 [default = 3];
  inline bool has_min_states() const;
  inline void clear_min_states();
  static const int kMinStatesFieldNumber = 1;
  inline ::google::protobuf::int32 min_states() const;
  inline void set_min_states(::google::protobuf::int32 value);

  // optional int32 max_states = 2 [default = 10];
  inline bool has_max_states() const;
  inline void clear_max_states();
  static const int kMaxStatesFieldNumber = 2;
  inline ::google::protobuf::int32 max_states() const;
  inline void set_max_states(::google::protobuf::int32 value);

  // optional int32 n_prms = 3 [default = 2];
  inline bool has_n_prms() const;
  inline void clear_n_prms();
  static const int kNPrmsFieldNumber = 3;
  inline ::google::protobuf::int32 n_prms() const;
  inline void set_n_prms(::google::protobuf::int32 value);

  // optional double mu = 4 [default = 0];
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 4;
  inline double mu() const;
  inline void set_mu(double value);

  // optional double std = 5 [default = 1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 5;
  inline double std() const;
  inline void set_std(double value);

  // required .MarkovChannel.MutationParameter mutation = 6;
  inline bool has_mutation() const;
  inline void clear_mutation();
  static const int kMutationFieldNumber = 6;
  inline const ::MarkovChannel::MutationParameter& mutation() const;
  inline ::MarkovChannel::MutationParameter* mutable_mutation();
  inline ::MarkovChannel::MutationParameter* release_mutation();
  inline void set_allocated_mutation(::MarkovChannel::MutationParameter* mutation);

  // @@protoc_insertion_point(class_scope:MarkovChannel.ModelParameter)
 private:
  inline void set_has_min_states();
  inline void clear_has_min_states();
  inline void set_has_max_states();
  inline void clear_has_max_states();
  inline void set_has_n_prms();
  inline void clear_has_n_prms();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_mutation();
  inline void clear_has_mutation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 min_states_;
  ::google::protobuf::int32 max_states_;
  double mu_;
  double std_;
  ::MarkovChannel::MutationParameter* mutation_;
  ::google::protobuf::int32 n_prms_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static ModelParameter* default_instance_;
};
// -------------------------------------------------------------------

class MutationParameter : public ::google::protobuf::Message {
 public:
  MutationParameter();
  virtual ~MutationParameter();

  MutationParameter(const MutationParameter& from);

  inline MutationParameter& operator=(const MutationParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MutationParameter& default_instance();

  void Swap(MutationParameter* other);

  // implements Message ----------------------------------------------

  MutationParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MutationParameter& from);
  void MergeFrom(const MutationParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double add_edge = 1;
  inline bool has_add_edge() const;
  inline void clear_add_edge();
  static const int kAddEdgeFieldNumber = 1;
  inline double add_edge() const;
  inline void set_add_edge(double value);

  // optional double add_node = 2;
  inline bool has_add_node() const;
  inline void clear_add_node();
  static const int kAddNodeFieldNumber = 2;
  inline double add_node() const;
  inline void set_add_node(double value);

  // optional double rm_edge = 3;
  inline bool has_rm_edge() const;
  inline void clear_rm_edge();
  static const int kRmEdgeFieldNumber = 3;
  inline double rm_edge() const;
  inline void set_rm_edge(double value);

  // optional double rm_node = 4;
  inline bool has_rm_node() const;
  inline void clear_rm_node();
  static const int kRmNodeFieldNumber = 4;
  inline double rm_node() const;
  inline void set_rm_node(double value);

  // optional double std = 5 [default = 0.1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 5;
  inline double std() const;
  inline void set_std(double value);

  // @@protoc_insertion_point(class_scope:MarkovChannel.MutationParameter)
 private:
  inline void set_has_add_edge();
  inline void clear_has_add_edge();
  inline void set_has_add_node();
  inline void clear_has_add_node();
  inline void set_has_rm_edge();
  inline void clear_has_rm_edge();
  inline void set_has_rm_node();
  inline void clear_has_rm_node();
  inline void set_has_std();
  inline void clear_has_std();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double add_edge_;
  double add_node_;
  double rm_edge_;
  double rm_node_;
  double std_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static MutationParameter* default_instance_;
};
// -------------------------------------------------------------------

class GAParameter : public ::google::protobuf::Message {
 public:
  GAParameter();
  virtual ~GAParameter();

  GAParameter(const GAParameter& from);

  inline GAParameter& operator=(const GAParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GAParameter& default_instance();

  void Swap(GAParameter* other);

  // implements Message ----------------------------------------------

  GAParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GAParameter& from);
  void MergeFrom(const GAParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GAParameter_SelectionMode SelectionMode;
  static const SelectionMode TOURNAMENT = GAParameter_SelectionMode_TOURNAMENT;
  static const SelectionMode PROPORTIONATE = GAParameter_SelectionMode_PROPORTIONATE;
  static const SelectionMode STOCHASTIC = GAParameter_SelectionMode_STOCHASTIC;
  static const SelectionMode UNIFORM = GAParameter_SelectionMode_UNIFORM;
  static const SelectionMode ROULETTE = GAParameter_SelectionMode_ROULETTE;
  static const SelectionMode RANK = GAParameter_SelectionMode_RANK;
  static inline bool SelectionMode_IsValid(int value) {
    return GAParameter_SelectionMode_IsValid(value);
  }
  static const SelectionMode SelectionMode_MIN =
    GAParameter_SelectionMode_SelectionMode_MIN;
  static const SelectionMode SelectionMode_MAX =
    GAParameter_SelectionMode_SelectionMode_MAX;
  static const int SelectionMode_ARRAYSIZE =
    GAParameter_SelectionMode_SelectionMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SelectionMode_descriptor() {
    return GAParameter_SelectionMode_descriptor();
  }
  static inline const ::std::string& SelectionMode_Name(SelectionMode value) {
    return GAParameter_SelectionMode_Name(value);
  }
  static inline bool SelectionMode_Parse(const ::std::string& name,
      SelectionMode* value) {
    return GAParameter_SelectionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 n_subpopulations = 1 [default = 8];
  inline bool has_n_subpopulations() const;
  inline void clear_n_subpopulations();
  static const int kNSubpopulationsFieldNumber = 1;
  inline ::google::protobuf::int32 n_subpopulations() const;
  inline void set_n_subpopulations(::google::protobuf::int32 value);

  // optional int32 population_size = 2 [default = 100];
  inline bool has_population_size() const;
  inline void clear_population_size();
  static const int kPopulationSizeFieldNumber = 2;
  inline ::google::protobuf::int32 population_size() const;
  inline void set_population_size(::google::protobuf::int32 value);

  // optional double migration_rate = 3 [default = 0.01];
  inline bool has_migration_rate() const;
  inline void clear_migration_rate();
  static const int kMigrationRateFieldNumber = 3;
  inline double migration_rate() const;
  inline void set_migration_rate(double value);

  // optional double reproduction_rate = 4 [default = 0.5];
  inline bool has_reproduction_rate() const;
  inline void clear_reproduction_rate();
  static const int kReproductionRateFieldNumber = 4;
  inline double reproduction_rate() const;
  inline void set_reproduction_rate(double value);

  // optional .MarkovChannel.GAParameter.SelectionMode selection_mode = 5 [default = TOURNAMENT];
  inline bool has_selection_mode() const;
  inline void clear_selection_mode();
  static const int kSelectionModeFieldNumber = 5;
  inline ::MarkovChannel::GAParameter_SelectionMode selection_mode() const;
  inline void set_selection_mode(::MarkovChannel::GAParameter_SelectionMode value);

  // optional .MarkovChannel.TransitionParameter mutation_param = 6;
  inline bool has_mutation_param() const;
  inline void clear_mutation_param();
  static const int kMutationParamFieldNumber = 6;
  inline const ::MarkovChannel::TransitionParameter& mutation_param() const;
  inline ::MarkovChannel::TransitionParameter* mutable_mutation_param();
  inline ::MarkovChannel::TransitionParameter* release_mutation_param();
  inline void set_allocated_mutation_param(::MarkovChannel::TransitionParameter* mutation_param);

  // @@protoc_insertion_point(class_scope:MarkovChannel.GAParameter)
 private:
  inline void set_has_n_subpopulations();
  inline void clear_has_n_subpopulations();
  inline void set_has_population_size();
  inline void clear_has_population_size();
  inline void set_has_migration_rate();
  inline void clear_has_migration_rate();
  inline void set_has_reproduction_rate();
  inline void clear_has_reproduction_rate();
  inline void set_has_selection_mode();
  inline void clear_has_selection_mode();
  inline void set_has_mutation_param();
  inline void clear_has_mutation_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 n_subpopulations_;
  ::google::protobuf::int32 population_size_;
  double migration_rate_;
  double reproduction_rate_;
  ::MarkovChannel::TransitionParameter* mutation_param_;
  int selection_mode_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static GAParameter* default_instance_;
};
// -------------------------------------------------------------------

class SAParameter : public ::google::protobuf::Message {
 public:
  SAParameter();
  virtual ~SAParameter();

  SAParameter(const SAParameter& from);

  inline SAParameter& operator=(const SAParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SAParameter& default_instance();

  void Swap(SAParameter* other);

  // implements Message ----------------------------------------------

  SAParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SAParameter& from);
  void MergeFrom(const SAParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 k_max = 1 [default = 100];
  inline bool has_k_max() const;
  inline void clear_k_max();
  static const int kKMaxFieldNumber = 1;
  inline ::google::protobuf::int32 k_max() const;
  inline void set_k_max(::google::protobuf::int32 value);

  // optional double gamma = 2 [default = 0.01];
  inline bool has_gamma() const;
  inline void clear_gamma();
  static const int kGammaFieldNumber = 2;
  inline double gamma() const;
  inline void set_gamma(double value);

  // optional .MarkovChannel.TransitionParameter transition_param = 3;
  inline bool has_transition_param() const;
  inline void clear_transition_param();
  static const int kTransitionParamFieldNumber = 3;
  inline const ::MarkovChannel::TransitionParameter& transition_param() const;
  inline ::MarkovChannel::TransitionParameter* mutable_transition_param();
  inline ::MarkovChannel::TransitionParameter* release_transition_param();
  inline void set_allocated_transition_param(::MarkovChannel::TransitionParameter* transition_param);

  // @@protoc_insertion_point(class_scope:MarkovChannel.SAParameter)
 private:
  inline void set_has_k_max();
  inline void clear_has_k_max();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_transition_param();
  inline void clear_has_transition_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double gamma_;
  ::MarkovChannel::TransitionParameter* transition_param_;
  ::google::protobuf::int32 k_max_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static SAParameter* default_instance_;
};
// -------------------------------------------------------------------

class TransitionParameter : public ::google::protobuf::Message {
 public:
  TransitionParameter();
  virtual ~TransitionParameter();

  TransitionParameter(const TransitionParameter& from);

  inline TransitionParameter& operator=(const TransitionParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitionParameter& default_instance();

  void Swap(TransitionParameter* other);

  // implements Message ----------------------------------------------

  TransitionParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransitionParameter& from);
  void MergeFrom(const TransitionParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double add_state = 1;
  inline bool has_add_state() const;
  inline void clear_add_state();
  static const int kAddStateFieldNumber = 1;
  inline double add_state() const;
  inline void set_add_state(double value);

  // optional double add_edge = 2;
  inline bool has_add_edge() const;
  inline void clear_add_edge();
  static const int kAddEdgeFieldNumber = 2;
  inline double add_edge() const;
  inline void set_add_edge(double value);

  // optional double remove_edge = 3;
  inline bool has_remove_edge() const;
  inline void clear_remove_edge();
  static const int kRemoveEdgeFieldNumber = 3;
  inline double remove_edge() const;
  inline void set_remove_edge(double value);

  // optional double shift_params = 4;
  inline bool has_shift_params() const;
  inline void clear_shift_params();
  static const int kShiftParamsFieldNumber = 4;
  inline double shift_params() const;
  inline void set_shift_params(double value);

  // optional bool fixed_model = 5 [default = false];
  inline bool has_fixed_model() const;
  inline void clear_fixed_model();
  static const int kFixedModelFieldNumber = 5;
  inline bool fixed_model() const;
  inline void set_fixed_model(bool value);

  // @@protoc_insertion_point(class_scope:MarkovChannel.TransitionParameter)
 private:
  inline void set_has_add_state();
  inline void clear_has_add_state();
  inline void set_has_add_edge();
  inline void clear_has_add_edge();
  inline void set_has_remove_edge();
  inline void clear_has_remove_edge();
  inline void set_has_shift_params();
  inline void clear_has_shift_params();
  inline void set_has_fixed_model();
  inline void clear_has_fixed_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double add_state_;
  double add_edge_;
  double remove_edge_;
  double shift_params_;
  bool fixed_model_;
  friend void  protobuf_AddDesc_MarkovChannel_2eproto();
  friend void protobuf_AssignDesc_MarkovChannel_2eproto();
  friend void protobuf_ShutdownFile_MarkovChannel_2eproto();

  void InitAsDefaultInstance();
  static TransitionParameter* default_instance_;
};
// ===================================================================


// ===================================================================

// ProtocolParameter

// required string name = 1;
inline bool ProtocolParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolParameter::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProtocolParameter::name() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolParameter.name)
  return *name_;
}
inline void ProtocolParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolParameter.name)
}
inline void ProtocolParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:MarkovChannel.ProtocolParameter.name)
}
inline void ProtocolParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MarkovChannel.ProtocolParameter.name)
}
inline ::std::string* ProtocolParameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MarkovChannel.ProtocolParameter.name)
  return name_;
}
inline ::std::string* ProtocolParameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtocolParameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.ProtocolParameter.name)
}

// optional string source = 2;
inline bool ProtocolParameter::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolParameter::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolParameter::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolParameter::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& ProtocolParameter::source() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolParameter.source)
  return *source_;
}
inline void ProtocolParameter::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolParameter.source)
}
inline void ProtocolParameter::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:MarkovChannel.ProtocolParameter.source)
}
inline void ProtocolParameter::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MarkovChannel.ProtocolParameter.source)
}
inline ::std::string* ProtocolParameter::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MarkovChannel.ProtocolParameter.source)
  return source_;
}
inline ::std::string* ProtocolParameter::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtocolParameter::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.ProtocolParameter.source)
}

// optional double v0 = 3 [default = -120];
inline bool ProtocolParameter::has_v0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolParameter::set_has_v0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolParameter::clear_has_v0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolParameter::clear_v0() {
  v0_ = -120;
  clear_has_v0();
}
inline double ProtocolParameter::v0() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolParameter.v0)
  return v0_;
}
inline void ProtocolParameter::set_v0(double value) {
  set_has_v0();
  v0_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolParameter.v0)
}

// optional double temperature = 4 [default = 293];
inline bool ProtocolParameter::has_temperature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtocolParameter::set_has_temperature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtocolParameter::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtocolParameter::clear_temperature() {
  temperature_ = 293;
  clear_has_temperature();
}
inline double ProtocolParameter::temperature() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolParameter.temperature)
  return temperature_;
}
inline void ProtocolParameter::set_temperature(double value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolParameter.temperature)
}

// repeated .MarkovChannel.ProtocolStep step = 5;
inline int ProtocolParameter::step_size() const {
  return step_.size();
}
inline void ProtocolParameter::clear_step() {
  step_.Clear();
}
inline const ::MarkovChannel::ProtocolStep& ProtocolParameter::step(int index) const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolParameter.step)
  return step_.Get(index);
}
inline ::MarkovChannel::ProtocolStep* ProtocolParameter::mutable_step(int index) {
  // @@protoc_insertion_point(field_mutable:MarkovChannel.ProtocolParameter.step)
  return step_.Mutable(index);
}
inline ::MarkovChannel::ProtocolStep* ProtocolParameter::add_step() {
  // @@protoc_insertion_point(field_add:MarkovChannel.ProtocolParameter.step)
  return step_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MarkovChannel::ProtocolStep >&
ProtocolParameter::step() const {
  // @@protoc_insertion_point(field_list:MarkovChannel.ProtocolParameter.step)
  return step_;
}
inline ::google::protobuf::RepeatedPtrField< ::MarkovChannel::ProtocolStep >*
ProtocolParameter::mutable_step() {
  // @@protoc_insertion_point(field_mutable_list:MarkovChannel.ProtocolParameter.step)
  return &step_;
}

// -------------------------------------------------------------------

// ProtocolStep

// optional double dt = 1;
inline bool ProtocolStep::has_dt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolStep::set_has_dt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolStep::clear_has_dt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolStep::clear_dt() {
  dt_ = 0;
  clear_has_dt();
}
inline double ProtocolStep::dt() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.dt)
  return dt_;
}
inline void ProtocolStep::set_dt(double value) {
  set_has_dt();
  dt_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.dt)
}

// optional double vm = 2;
inline bool ProtocolStep::has_vm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolStep::set_has_vm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolStep::clear_has_vm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolStep::clear_vm() {
  vm_ = 0;
  clear_has_vm();
}
inline double ProtocolStep::vm() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.vm)
  return vm_;
}
inline void ProtocolStep::set_vm(double value) {
  set_has_vm();
  vm_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.vm)
}

// optional bool conductance = 3;
inline bool ProtocolStep::has_conductance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolStep::set_has_conductance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolStep::clear_has_conductance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolStep::clear_conductance() {
  conductance_ = false;
  clear_has_conductance();
}
inline bool ProtocolStep::conductance() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.conductance)
  return conductance_;
}
inline void ProtocolStep::set_conductance(bool value) {
  set_has_conductance();
  conductance_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.conductance)
}

// optional bool fluorimetry = 4;
inline bool ProtocolStep::has_fluorimetry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtocolStep::set_has_fluorimetry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtocolStep::clear_has_fluorimetry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtocolStep::clear_fluorimetry() {
  fluorimetry_ = false;
  clear_has_fluorimetry();
}
inline bool ProtocolStep::fluorimetry() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.fluorimetry)
  return fluorimetry_;
}
inline void ProtocolStep::set_fluorimetry(bool value) {
  set_has_fluorimetry();
  fluorimetry_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.fluorimetry)
}

// optional .MarkovChannel.ProtocolStep.StepType stype = 5 [default = NONE];
inline bool ProtocolStep::has_stype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtocolStep::set_has_stype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtocolStep::clear_has_stype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtocolStep::clear_stype() {
  stype_ = 0;
  clear_has_stype();
}
inline ::MarkovChannel::ProtocolStep_StepType ProtocolStep::stype() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.stype)
  return static_cast< ::MarkovChannel::ProtocolStep_StepType >(stype_);
}
inline void ProtocolStep::set_stype(::MarkovChannel::ProtocolStep_StepType value) {
  assert(::MarkovChannel::ProtocolStep_StepType_IsValid(value));
  set_has_stype();
  stype_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.stype)
}

// optional bool normalize = 6 [default = true];
inline bool ProtocolStep::has_normalize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtocolStep::set_has_normalize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtocolStep::clear_has_normalize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtocolStep::clear_normalize() {
  normalize_ = true;
  clear_has_normalize();
}
inline bool ProtocolStep::normalize() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.normalize)
  return normalize_;
}
inline void ProtocolStep::set_normalize(bool value) {
  set_has_normalize();
  normalize_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.normalize)
}

// optional double prm1 = 7 [default = 0.1];
inline bool ProtocolStep::has_prm1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtocolStep::set_has_prm1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtocolStep::clear_has_prm1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtocolStep::clear_prm1() {
  prm1_ = 0.1;
  clear_has_prm1();
}
inline double ProtocolStep::prm1() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.prm1)
  return prm1_;
}
inline void ProtocolStep::set_prm1(double value) {
  set_has_prm1();
  prm1_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.prm1)
}

// optional double prm2 = 8 [default = 0.9];
inline bool ProtocolStep::has_prm2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtocolStep::set_has_prm2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtocolStep::clear_has_prm2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtocolStep::clear_prm2() {
  prm2_ = 0.9;
  clear_has_prm2();
}
inline double ProtocolStep::prm2() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.prm2)
  return prm2_;
}
inline void ProtocolStep::set_prm2(double value) {
  set_has_prm2();
  prm2_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.prm2)
}

// optional double stepsize = 9 [default = 0.1];
inline bool ProtocolStep::has_stepsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtocolStep::set_has_stepsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtocolStep::clear_has_stepsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtocolStep::clear_stepsize() {
  stepsize_ = 0.1;
  clear_has_stepsize();
}
inline double ProtocolStep::stepsize() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ProtocolStep.stepsize)
  return stepsize_;
}
inline void ProtocolStep::set_stepsize(double value) {
  set_has_stepsize();
  stepsize_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ProtocolStep.stepsize)
}

// -------------------------------------------------------------------

// SolverParameter

// optional .MarkovChannel.SolverParameter.SolverMode solver_mode = 1 [default = GENETIC_ALGORITHM];
inline bool SolverParameter::has_solver_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverParameter::set_has_solver_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverParameter::clear_has_solver_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverParameter::clear_solver_mode() {
  solver_mode_ = 0;
  clear_has_solver_mode();
}
inline ::MarkovChannel::SolverParameter_SolverMode SolverParameter::solver_mode() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.solver_mode)
  return static_cast< ::MarkovChannel::SolverParameter_SolverMode >(solver_mode_);
}
inline void SolverParameter::set_solver_mode(::MarkovChannel::SolverParameter_SolverMode value) {
  assert(::MarkovChannel::SolverParameter_SolverMode_IsValid(value));
  set_has_solver_mode();
  solver_mode_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.SolverParameter.solver_mode)
}

// optional .MarkovChannel.SolverParameter.SimulationMode simulation_mode = 2 [default = ODE];
inline bool SolverParameter::has_simulation_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverParameter::set_has_simulation_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverParameter::clear_has_simulation_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverParameter::clear_simulation_mode() {
  simulation_mode_ = 0;
  clear_has_simulation_mode();
}
inline ::MarkovChannel::SolverParameter_SimulationMode SolverParameter::simulation_mode() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.simulation_mode)
  return static_cast< ::MarkovChannel::SolverParameter_SimulationMode >(simulation_mode_);
}
inline void SolverParameter::set_simulation_mode(::MarkovChannel::SolverParameter_SimulationMode value) {
  assert(::MarkovChannel::SolverParameter_SimulationMode_IsValid(value));
  set_has_simulation_mode();
  simulation_mode_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.SolverParameter.simulation_mode)
}

// required .MarkovChannel.ModelParameter model_param = 3;
inline bool SolverParameter::has_model_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverParameter::set_has_model_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverParameter::clear_has_model_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverParameter::clear_model_param() {
  if (model_param_ != NULL) model_param_->::MarkovChannel::ModelParameter::Clear();
  clear_has_model_param();
}
inline const ::MarkovChannel::ModelParameter& SolverParameter::model_param() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.model_param)
  return model_param_ != NULL ? *model_param_ : *default_instance_->model_param_;
}
inline ::MarkovChannel::ModelParameter* SolverParameter::mutable_model_param() {
  set_has_model_param();
  if (model_param_ == NULL) model_param_ = new ::MarkovChannel::ModelParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.SolverParameter.model_param)
  return model_param_;
}
inline ::MarkovChannel::ModelParameter* SolverParameter::release_model_param() {
  clear_has_model_param();
  ::MarkovChannel::ModelParameter* temp = model_param_;
  model_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_model_param(::MarkovChannel::ModelParameter* model_param) {
  delete model_param_;
  model_param_ = model_param;
  if (model_param) {
    set_has_model_param();
  } else {
    clear_has_model_param();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.SolverParameter.model_param)
}

// optional int32 max_iters = 4 [default = 10000];
inline bool SolverParameter::has_max_iters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverParameter::set_has_max_iters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverParameter::clear_has_max_iters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverParameter::clear_max_iters() {
  max_iters_ = 10000;
  clear_has_max_iters();
}
inline ::google::protobuf::int32 SolverParameter::max_iters() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.max_iters)
  return max_iters_;
}
inline void SolverParameter::set_max_iters(::google::protobuf::int32 value) {
  set_has_max_iters();
  max_iters_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.SolverParameter.max_iters)
}

// optional .MarkovChannel.GAParameter ga_param = 5;
inline bool SolverParameter::has_ga_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolverParameter::set_has_ga_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolverParameter::clear_has_ga_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolverParameter::clear_ga_param() {
  if (ga_param_ != NULL) ga_param_->::MarkovChannel::GAParameter::Clear();
  clear_has_ga_param();
}
inline const ::MarkovChannel::GAParameter& SolverParameter::ga_param() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.ga_param)
  return ga_param_ != NULL ? *ga_param_ : *default_instance_->ga_param_;
}
inline ::MarkovChannel::GAParameter* SolverParameter::mutable_ga_param() {
  set_has_ga_param();
  if (ga_param_ == NULL) ga_param_ = new ::MarkovChannel::GAParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.SolverParameter.ga_param)
  return ga_param_;
}
inline ::MarkovChannel::GAParameter* SolverParameter::release_ga_param() {
  clear_has_ga_param();
  ::MarkovChannel::GAParameter* temp = ga_param_;
  ga_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_ga_param(::MarkovChannel::GAParameter* ga_param) {
  delete ga_param_;
  ga_param_ = ga_param;
  if (ga_param) {
    set_has_ga_param();
  } else {
    clear_has_ga_param();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.SolverParameter.ga_param)
}

// optional .MarkovChannel.SAParameter sa_param = 6;
inline bool SolverParameter::has_sa_param() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolverParameter::set_has_sa_param() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolverParameter::clear_has_sa_param() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolverParameter::clear_sa_param() {
  if (sa_param_ != NULL) sa_param_->::MarkovChannel::SAParameter::Clear();
  clear_has_sa_param();
}
inline const ::MarkovChannel::SAParameter& SolverParameter::sa_param() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SolverParameter.sa_param)
  return sa_param_ != NULL ? *sa_param_ : *default_instance_->sa_param_;
}
inline ::MarkovChannel::SAParameter* SolverParameter::mutable_sa_param() {
  set_has_sa_param();
  if (sa_param_ == NULL) sa_param_ = new ::MarkovChannel::SAParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.SolverParameter.sa_param)
  return sa_param_;
}
inline ::MarkovChannel::SAParameter* SolverParameter::release_sa_param() {
  clear_has_sa_param();
  ::MarkovChannel::SAParameter* temp = sa_param_;
  sa_param_ = NULL;
  return temp;
}
inline void SolverParameter::set_allocated_sa_param(::MarkovChannel::SAParameter* sa_param) {
  delete sa_param_;
  sa_param_ = sa_param;
  if (sa_param) {
    set_has_sa_param();
  } else {
    clear_has_sa_param();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.SolverParameter.sa_param)
}

// -------------------------------------------------------------------

// ModelParameter

// optional int32 min_states = 1 [default = 3];
inline bool ModelParameter::has_min_states() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelParameter::set_has_min_states() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelParameter::clear_has_min_states() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelParameter::clear_min_states() {
  min_states_ = 3;
  clear_has_min_states();
}
inline ::google::protobuf::int32 ModelParameter::min_states() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.min_states)
  return min_states_;
}
inline void ModelParameter::set_min_states(::google::protobuf::int32 value) {
  set_has_min_states();
  min_states_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ModelParameter.min_states)
}

// optional int32 max_states = 2 [default = 10];
inline bool ModelParameter::has_max_states() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelParameter::set_has_max_states() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelParameter::clear_has_max_states() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelParameter::clear_max_states() {
  max_states_ = 10;
  clear_has_max_states();
}
inline ::google::protobuf::int32 ModelParameter::max_states() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.max_states)
  return max_states_;
}
inline void ModelParameter::set_max_states(::google::protobuf::int32 value) {
  set_has_max_states();
  max_states_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ModelParameter.max_states)
}

// optional int32 n_prms = 3 [default = 2];
inline bool ModelParameter::has_n_prms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelParameter::set_has_n_prms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelParameter::clear_has_n_prms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelParameter::clear_n_prms() {
  n_prms_ = 2;
  clear_has_n_prms();
}
inline ::google::protobuf::int32 ModelParameter::n_prms() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.n_prms)
  return n_prms_;
}
inline void ModelParameter::set_n_prms(::google::protobuf::int32 value) {
  set_has_n_prms();
  n_prms_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ModelParameter.n_prms)
}

// optional double mu = 4 [default = 0];
inline bool ModelParameter::has_mu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelParameter::set_has_mu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelParameter::clear_has_mu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelParameter::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline double ModelParameter::mu() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.mu)
  return mu_;
}
inline void ModelParameter::set_mu(double value) {
  set_has_mu();
  mu_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ModelParameter.mu)
}

// optional double std = 5 [default = 1];
inline bool ModelParameter::has_std() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelParameter::set_has_std() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelParameter::clear_has_std() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelParameter::clear_std() {
  std_ = 1;
  clear_has_std();
}
inline double ModelParameter::std() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.std)
  return std_;
}
inline void ModelParameter::set_std(double value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.ModelParameter.std)
}

// required .MarkovChannel.MutationParameter mutation = 6;
inline bool ModelParameter::has_mutation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModelParameter::set_has_mutation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModelParameter::clear_has_mutation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModelParameter::clear_mutation() {
  if (mutation_ != NULL) mutation_->::MarkovChannel::MutationParameter::Clear();
  clear_has_mutation();
}
inline const ::MarkovChannel::MutationParameter& ModelParameter::mutation() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.ModelParameter.mutation)
  return mutation_ != NULL ? *mutation_ : *default_instance_->mutation_;
}
inline ::MarkovChannel::MutationParameter* ModelParameter::mutable_mutation() {
  set_has_mutation();
  if (mutation_ == NULL) mutation_ = new ::MarkovChannel::MutationParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.ModelParameter.mutation)
  return mutation_;
}
inline ::MarkovChannel::MutationParameter* ModelParameter::release_mutation() {
  clear_has_mutation();
  ::MarkovChannel::MutationParameter* temp = mutation_;
  mutation_ = NULL;
  return temp;
}
inline void ModelParameter::set_allocated_mutation(::MarkovChannel::MutationParameter* mutation) {
  delete mutation_;
  mutation_ = mutation;
  if (mutation) {
    set_has_mutation();
  } else {
    clear_has_mutation();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.ModelParameter.mutation)
}

// -------------------------------------------------------------------

// MutationParameter

// optional double add_edge = 1;
inline bool MutationParameter::has_add_edge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationParameter::set_has_add_edge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MutationParameter::clear_has_add_edge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MutationParameter::clear_add_edge() {
  add_edge_ = 0;
  clear_has_add_edge();
}
inline double MutationParameter::add_edge() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.MutationParameter.add_edge)
  return add_edge_;
}
inline void MutationParameter::set_add_edge(double value) {
  set_has_add_edge();
  add_edge_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.MutationParameter.add_edge)
}

// optional double add_node = 2;
inline bool MutationParameter::has_add_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutationParameter::set_has_add_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MutationParameter::clear_has_add_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MutationParameter::clear_add_node() {
  add_node_ = 0;
  clear_has_add_node();
}
inline double MutationParameter::add_node() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.MutationParameter.add_node)
  return add_node_;
}
inline void MutationParameter::set_add_node(double value) {
  set_has_add_node();
  add_node_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.MutationParameter.add_node)
}

// optional double rm_edge = 3;
inline bool MutationParameter::has_rm_edge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutationParameter::set_has_rm_edge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MutationParameter::clear_has_rm_edge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MutationParameter::clear_rm_edge() {
  rm_edge_ = 0;
  clear_has_rm_edge();
}
inline double MutationParameter::rm_edge() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.MutationParameter.rm_edge)
  return rm_edge_;
}
inline void MutationParameter::set_rm_edge(double value) {
  set_has_rm_edge();
  rm_edge_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.MutationParameter.rm_edge)
}

// optional double rm_node = 4;
inline bool MutationParameter::has_rm_node() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutationParameter::set_has_rm_node() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MutationParameter::clear_has_rm_node() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MutationParameter::clear_rm_node() {
  rm_node_ = 0;
  clear_has_rm_node();
}
inline double MutationParameter::rm_node() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.MutationParameter.rm_node)
  return rm_node_;
}
inline void MutationParameter::set_rm_node(double value) {
  set_has_rm_node();
  rm_node_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.MutationParameter.rm_node)
}

// optional double std = 5 [default = 0.1];
inline bool MutationParameter::has_std() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MutationParameter::set_has_std() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MutationParameter::clear_has_std() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MutationParameter::clear_std() {
  std_ = 0.1;
  clear_has_std();
}
inline double MutationParameter::std() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.MutationParameter.std)
  return std_;
}
inline void MutationParameter::set_std(double value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.MutationParameter.std)
}

// -------------------------------------------------------------------

// GAParameter

// optional int32 n_subpopulations = 1 [default = 8];
inline bool GAParameter::has_n_subpopulations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GAParameter::set_has_n_subpopulations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GAParameter::clear_has_n_subpopulations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GAParameter::clear_n_subpopulations() {
  n_subpopulations_ = 8;
  clear_has_n_subpopulations();
}
inline ::google::protobuf::int32 GAParameter::n_subpopulations() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.n_subpopulations)
  return n_subpopulations_;
}
inline void GAParameter::set_n_subpopulations(::google::protobuf::int32 value) {
  set_has_n_subpopulations();
  n_subpopulations_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.GAParameter.n_subpopulations)
}

// optional int32 population_size = 2 [default = 100];
inline bool GAParameter::has_population_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GAParameter::set_has_population_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GAParameter::clear_has_population_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GAParameter::clear_population_size() {
  population_size_ = 100;
  clear_has_population_size();
}
inline ::google::protobuf::int32 GAParameter::population_size() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.population_size)
  return population_size_;
}
inline void GAParameter::set_population_size(::google::protobuf::int32 value) {
  set_has_population_size();
  population_size_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.GAParameter.population_size)
}

// optional double migration_rate = 3 [default = 0.01];
inline bool GAParameter::has_migration_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GAParameter::set_has_migration_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GAParameter::clear_has_migration_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GAParameter::clear_migration_rate() {
  migration_rate_ = 0.01;
  clear_has_migration_rate();
}
inline double GAParameter::migration_rate() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.migration_rate)
  return migration_rate_;
}
inline void GAParameter::set_migration_rate(double value) {
  set_has_migration_rate();
  migration_rate_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.GAParameter.migration_rate)
}

// optional double reproduction_rate = 4 [default = 0.5];
inline bool GAParameter::has_reproduction_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GAParameter::set_has_reproduction_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GAParameter::clear_has_reproduction_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GAParameter::clear_reproduction_rate() {
  reproduction_rate_ = 0.5;
  clear_has_reproduction_rate();
}
inline double GAParameter::reproduction_rate() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.reproduction_rate)
  return reproduction_rate_;
}
inline void GAParameter::set_reproduction_rate(double value) {
  set_has_reproduction_rate();
  reproduction_rate_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.GAParameter.reproduction_rate)
}

// optional .MarkovChannel.GAParameter.SelectionMode selection_mode = 5 [default = TOURNAMENT];
inline bool GAParameter::has_selection_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GAParameter::set_has_selection_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GAParameter::clear_has_selection_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GAParameter::clear_selection_mode() {
  selection_mode_ = 0;
  clear_has_selection_mode();
}
inline ::MarkovChannel::GAParameter_SelectionMode GAParameter::selection_mode() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.selection_mode)
  return static_cast< ::MarkovChannel::GAParameter_SelectionMode >(selection_mode_);
}
inline void GAParameter::set_selection_mode(::MarkovChannel::GAParameter_SelectionMode value) {
  assert(::MarkovChannel::GAParameter_SelectionMode_IsValid(value));
  set_has_selection_mode();
  selection_mode_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.GAParameter.selection_mode)
}

// optional .MarkovChannel.TransitionParameter mutation_param = 6;
inline bool GAParameter::has_mutation_param() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GAParameter::set_has_mutation_param() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GAParameter::clear_has_mutation_param() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GAParameter::clear_mutation_param() {
  if (mutation_param_ != NULL) mutation_param_->::MarkovChannel::TransitionParameter::Clear();
  clear_has_mutation_param();
}
inline const ::MarkovChannel::TransitionParameter& GAParameter::mutation_param() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.GAParameter.mutation_param)
  return mutation_param_ != NULL ? *mutation_param_ : *default_instance_->mutation_param_;
}
inline ::MarkovChannel::TransitionParameter* GAParameter::mutable_mutation_param() {
  set_has_mutation_param();
  if (mutation_param_ == NULL) mutation_param_ = new ::MarkovChannel::TransitionParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.GAParameter.mutation_param)
  return mutation_param_;
}
inline ::MarkovChannel::TransitionParameter* GAParameter::release_mutation_param() {
  clear_has_mutation_param();
  ::MarkovChannel::TransitionParameter* temp = mutation_param_;
  mutation_param_ = NULL;
  return temp;
}
inline void GAParameter::set_allocated_mutation_param(::MarkovChannel::TransitionParameter* mutation_param) {
  delete mutation_param_;
  mutation_param_ = mutation_param;
  if (mutation_param) {
    set_has_mutation_param();
  } else {
    clear_has_mutation_param();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.GAParameter.mutation_param)
}

// -------------------------------------------------------------------

// SAParameter

// optional int32 k_max = 1 [default = 100];
inline bool SAParameter::has_k_max() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SAParameter::set_has_k_max() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SAParameter::clear_has_k_max() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SAParameter::clear_k_max() {
  k_max_ = 100;
  clear_has_k_max();
}
inline ::google::protobuf::int32 SAParameter::k_max() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SAParameter.k_max)
  return k_max_;
}
inline void SAParameter::set_k_max(::google::protobuf::int32 value) {
  set_has_k_max();
  k_max_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.SAParameter.k_max)
}

// optional double gamma = 2 [default = 0.01];
inline bool SAParameter::has_gamma() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SAParameter::set_has_gamma() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SAParameter::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SAParameter::clear_gamma() {
  gamma_ = 0.01;
  clear_has_gamma();
}
inline double SAParameter::gamma() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SAParameter.gamma)
  return gamma_;
}
inline void SAParameter::set_gamma(double value) {
  set_has_gamma();
  gamma_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.SAParameter.gamma)
}

// optional .MarkovChannel.TransitionParameter transition_param = 3;
inline bool SAParameter::has_transition_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SAParameter::set_has_transition_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SAParameter::clear_has_transition_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SAParameter::clear_transition_param() {
  if (transition_param_ != NULL) transition_param_->::MarkovChannel::TransitionParameter::Clear();
  clear_has_transition_param();
}
inline const ::MarkovChannel::TransitionParameter& SAParameter::transition_param() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.SAParameter.transition_param)
  return transition_param_ != NULL ? *transition_param_ : *default_instance_->transition_param_;
}
inline ::MarkovChannel::TransitionParameter* SAParameter::mutable_transition_param() {
  set_has_transition_param();
  if (transition_param_ == NULL) transition_param_ = new ::MarkovChannel::TransitionParameter;
  // @@protoc_insertion_point(field_mutable:MarkovChannel.SAParameter.transition_param)
  return transition_param_;
}
inline ::MarkovChannel::TransitionParameter* SAParameter::release_transition_param() {
  clear_has_transition_param();
  ::MarkovChannel::TransitionParameter* temp = transition_param_;
  transition_param_ = NULL;
  return temp;
}
inline void SAParameter::set_allocated_transition_param(::MarkovChannel::TransitionParameter* transition_param) {
  delete transition_param_;
  transition_param_ = transition_param;
  if (transition_param) {
    set_has_transition_param();
  } else {
    clear_has_transition_param();
  }
  // @@protoc_insertion_point(field_set_allocated:MarkovChannel.SAParameter.transition_param)
}

// -------------------------------------------------------------------

// TransitionParameter

// optional double add_state = 1;
inline bool TransitionParameter::has_add_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitionParameter::set_has_add_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitionParameter::clear_has_add_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitionParameter::clear_add_state() {
  add_state_ = 0;
  clear_has_add_state();
}
inline double TransitionParameter::add_state() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.TransitionParameter.add_state)
  return add_state_;
}
inline void TransitionParameter::set_add_state(double value) {
  set_has_add_state();
  add_state_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.TransitionParameter.add_state)
}

// optional double add_edge = 2;
inline bool TransitionParameter::has_add_edge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitionParameter::set_has_add_edge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitionParameter::clear_has_add_edge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitionParameter::clear_add_edge() {
  add_edge_ = 0;
  clear_has_add_edge();
}
inline double TransitionParameter::add_edge() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.TransitionParameter.add_edge)
  return add_edge_;
}
inline void TransitionParameter::set_add_edge(double value) {
  set_has_add_edge();
  add_edge_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.TransitionParameter.add_edge)
}

// optional double remove_edge = 3;
inline bool TransitionParameter::has_remove_edge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitionParameter::set_has_remove_edge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitionParameter::clear_has_remove_edge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitionParameter::clear_remove_edge() {
  remove_edge_ = 0;
  clear_has_remove_edge();
}
inline double TransitionParameter::remove_edge() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.TransitionParameter.remove_edge)
  return remove_edge_;
}
inline void TransitionParameter::set_remove_edge(double value) {
  set_has_remove_edge();
  remove_edge_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.TransitionParameter.remove_edge)
}

// optional double shift_params = 4;
inline bool TransitionParameter::has_shift_params() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransitionParameter::set_has_shift_params() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransitionParameter::clear_has_shift_params() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransitionParameter::clear_shift_params() {
  shift_params_ = 0;
  clear_has_shift_params();
}
inline double TransitionParameter::shift_params() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.TransitionParameter.shift_params)
  return shift_params_;
}
inline void TransitionParameter::set_shift_params(double value) {
  set_has_shift_params();
  shift_params_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.TransitionParameter.shift_params)
}

// optional bool fixed_model = 5 [default = false];
inline bool TransitionParameter::has_fixed_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransitionParameter::set_has_fixed_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransitionParameter::clear_has_fixed_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransitionParameter::clear_fixed_model() {
  fixed_model_ = false;
  clear_has_fixed_model();
}
inline bool TransitionParameter::fixed_model() const {
  // @@protoc_insertion_point(field_get:MarkovChannel.TransitionParameter.fixed_model)
  return fixed_model_;
}
inline void TransitionParameter::set_fixed_model(bool value) {
  set_has_fixed_model();
  fixed_model_ = value;
  // @@protoc_insertion_point(field_set:MarkovChannel.TransitionParameter.fixed_model)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MarkovChannel

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MarkovChannel::ProtocolStep_StepType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarkovChannel::ProtocolStep_StepType>() {
  return ::MarkovChannel::ProtocolStep_StepType_descriptor();
}
template <> struct is_proto_enum< ::MarkovChannel::SolverParameter_SolverMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarkovChannel::SolverParameter_SolverMode>() {
  return ::MarkovChannel::SolverParameter_SolverMode_descriptor();
}
template <> struct is_proto_enum< ::MarkovChannel::SolverParameter_SimulationMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarkovChannel::SolverParameter_SimulationMode>() {
  return ::MarkovChannel::SolverParameter_SimulationMode_descriptor();
}
template <> struct is_proto_enum< ::MarkovChannel::GAParameter_SelectionMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarkovChannel::GAParameter_SelectionMode>() {
  return ::MarkovChannel::GAParameter_SelectionMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MarkovChannel_2eproto__INCLUDED
